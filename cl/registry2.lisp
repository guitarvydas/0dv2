(defun container-initializer (reg decl)
  ;; instantiating ("initializing") a Container is relatively simple in principle
  ;; 2 things need to happen:
  ;;  1. instantiate fresh copies of all children components contained by the Container, as specified by the prototype
  ;;  2. instantiate fresh connections between all of the new child instances and/or the Container itself, as specified by the prototype
  (let ((self (Container/new (slot-value decl 'name))))
    (loop for child-decl in decl
          do (let ((name (slot-value child-decl 'name)))
               (multiple-value-bind (child-instance ok) (get-component-instance reg name)
                 (if (not ok)
                     (error (format nil "Can't find component ~a" name))
                   (insert-and-mutate child-instance (slot-value self 'children))))))
    (let ((connections nil))
      (loop for proto-conn in (slot-value decl 'connections)
	    do (let ((conn (Connector/new nil nil nil)))
                 (case (slot-value proto-conn 'direction)
                   (down
                    (setf (slot-value conn 'direction) 'down)
                    ;; (setf conn.sender (Sender/new 'self proto-conn.sender.port))
                    (setf (slot-value conn 'sender) (Sender/new 'self (slot-value (slot-value proto-conn 'sender) 'port)))
                    ;; (setf conn.receiver (Receiver/new proto-conn.receiver.component.input proto-conn.receiver.port))
                    (setf (slot-value conn 'receiver) 
                          (Receiver/new (slot-value (slot-value (slot-value proto-conn 'receiver) 'component) 'input)
                                        (slot-value (slot-value proto-conn 'receiver) 'port))))
                   (across
                    (setf (slot-value conn 'direction) 'across)
                    ;; (setf conn.sender (Sender/new proto-conn.sender.component proto-conn.sender.port))
                    (setf (slot-value conn 'sender) 
                          (Sender/new (slot-value (slot-value proto-conn 'sender) 'component)
                                      (slot-value (slot-value proto-conn 'sender) 'port)))
                    ;; (setf conn.receiver (Receiver/new proto-conn.receiver.component.input proto-conn.receiver.port))
                    (setf (slot-value conn 'receiver) 
                          (Receiver/new (slot-value (slot-value (slot-value proto-conn 'receiver) 'component) 'input)
                                        (slot-value (slot-value proto-conn 'receiver) 'port))))
                   (up
                    (setf (slot-value conn 'direction) 'up)
                    ;; (setf conn.sender (Sender/new proto-conn.sender.component proto-conn.sender.port))
                    (setf (slot-value conn 'sender) 
                          (Sender/new (slot-value (slot-value proto-conn 'sender) 'component)
                                      (slot-value (slot-value proto-conn 'sender) 'port)))
                    ;; (setf conn.receiver (Receiver/new self.output proto-conn.receiver.port))
                    (setf (slot-value conn 'receiver) 
                          (Receiver/new (slot-value self 'output)
                                        (slot-value (slot-value proto-conn 'port) 'port))))
                   (through
                    (setf (slot-value conn 'direction) 'through)
                    ;; (setf conn.sender (Receiver/new 'self proto-conn.sender.port))
                    (setf (slot-value conn 'sender) (Sender/new 'self (slot-value (slot-value proto-conn 'sender) 'port)))
                    ;; (setf conn.receiver (Receiver/new self.output proto-conn.receiver.port))
                    (setf (slot-value conn 'receiver) 
                          (Receiver/new (slot-value self 'output)
                                        (slot-value (slot-value proto-conn 'receiver) 'port))))
                   )
                 (insert-and-mutate conn connections)))
      (setf (slot-value self connections) connections))
    self))