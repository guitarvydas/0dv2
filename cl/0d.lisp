;; generated by ChatGPT (see 0d-prompt.md)
;; then, corrected and tweaked by Paul Tarvydas

(defstruct eh
  name
  input
  output
  yield
  children
  connections
  handler
  leaf-handler
  instance-data
  state)

(defun EH/fresh (name)
  (let ((eh (make-eh)))
    (setf (eh-name eh) name
          (eh-input eh) (FIFO/fresh nil)
	  (eh-output eh) (FIFO/fresh nil)
	  (eh-yield eh) (FIFO/fresh nil))
    eh))

(defun Container/fresh (name)
  (let ((eh (EH/fresh name)))
    (setf (eh-handler eh) #'container-handler
          (eh-instance-data eh) nil)
    eh))

(defun Leaf/fresh (name handler &optional (instance-data nil))
  (let ((eh (EH/fresh name)))
    (setf (eh-handler eh) handler
	  (eh-instance-data eh) instance-data)
    eh))

(defun send (eh port data)
  (let ((uncloned-msg (Message/fresh :port port :datum data)))
    (let ((msg (clone uncloned-msg)))
      (enqueue (eh-output eh) msg))))

(defun yield (eh port data)
  (let ((uncloned-msg (Message/fresh :port port :datum data)))
    (let ((msg (clone uncloned-msg)))
      (enqueue (eh-yield eh) msg))))

(defun container-handler (eh message)
  (route eh eh message)
  (loop until (not (any-child-ready eh))
        do (step-children eh)))

(defun set-state (eh state)
  (setf (eh-state eh) state))

(defun deposit (connector message)
  (let ((recvr (connector-receiver connector)))
      (if (not (null recvr))
	  (let ((uncloned-new-message (Message/fresh :port (receiver-port (connector-receiver connector))
					    :datum (message-datum message))))
	    (let ((new-message (clone uncloned-new-message)))
	      (enqueue (receiver-queue recvr) new-message))))))

(defun step1 (container child fifo)
  (let ((input-msg (dequeue fifo)))
    (funcall (eh-handler child) child input-msg)
    (loop while (not (empty? (eh-output child)))
	  do (let ((output-message (dequeue (eh-output child))))
	       (route container child output-message)
	       (destroy output-message)))))
  
(defun step-children (container)
  (dolist (child (eh-children container))
    (if (not (empty? (eh-yield child)))
	(step1 container child (eh-yield child))
       (if (not (empty? (eh-input child)))
	   (step1 container child (eh-input child))))))

(defun route (container from message)
  (let ((from-sender (Sender/fresh :component from :port (message-port message))))
    (dolist (connector (eh-connections container))
      (when (=? from-sender (connector-sender connector))
        (deposit connector message)))))

(defun any-child-ready (container)
  (dolist (child (eh-children container))
    (when (child-is-ready child)
      (return-from any-child-ready t)))
  nil)

(defun child-is-ready (eh)
  (or (not (empty? (eh-input eh)))
      (not (empty? (eh-yield eh)))))

(defun insert-and-mutate (v lis)
  (push v lis))
