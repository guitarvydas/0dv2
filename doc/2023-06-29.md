Whitespace is overloaded, in general.  To used Ohm-JS whitespace-ignoring features, it seems that you need to break whitespace down into categories
1. input whitespace (whitespace in the original source code to be parsed)
2. output whitespace (generated by parser/emitter)
3. whitespace in comments
4. whitespace in strings
5. whitespace in character constants.

It is probably useful to keep blanks and newlines separated.  That means 5 kinds of blanks and 5 kinds of newlines.

Note that Ohm-JS combines spaces and newlines into a single, skippable category.  Ohm-JS skips only one kind of space/newline - by default " " and "\n".

Using different character runes for each kind of space and newline allows for better control of which characters are skipped by Ohm-JS.  For example, spaces that appear in strings should not usually be skipped.  OTOH, spaces in strings might be useful for parsing *pragmas* in strings.

Revised, suggested Unicode runes:
`“...”` strings
`❛.❜` rune literals
`❲...❳` symbols
`‹...›` keywords
`⟨...⟩` numbers
`⎣...⎦` comments
`⟪...⟫` multi-char operators
`⇢` indent
`⇠` dedent
`«...»` verbatim

`"・"` spaces/tabs in input (original)
`"⦚"` newlines in input (original)
`" "` spaces in output (generated) (normal space)
`"\n"` newlines in output (normal newline)
`"◦"` spaces in comments
`"¶"` newlines in comments
`"□"` spaces in strings
`"‡"` newlines in strings
`"☐"` spaces in character constants
`"†"` newlines in character constants

thought: Another option might be to use url encoding to map all unprintables into ASCII sequences.  There are many url encoding/decoding libraries which could be used.  OTOH, Unicode characters are directly parseable by Ohm-JS, whereas  ASCII sequences will require extra work before the space-skipping features of Ohm-JS can be used. 